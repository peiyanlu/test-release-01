import { execAsync, isGitRepo, parseGitHubRepo, readJsonFile, runGit, runNpm } from "@peiyanlu/cli-utils";
import { blue, dim, gray, green, red, rgb, yellow } from "ansis";
import { program } from "commander";
import path, { dirname, join, resolve } from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { cancel, confirm, group, intro, isCancel, log, outro, select, tasks, text } from "@clack/prompts";
import { inspect, styleText } from "node:util";
import { clean, coerce, gt, gte, inc, parse, prerelease, valid } from "semver";
import { createReadStream, existsSync, statSync } from "node:fs";
import { EOL } from "node:os";
import { readFile, writeFile } from "node:fs/promises";
import { Octokit } from "@octokit/rest";
import { contentType } from "mime-types";
import open from "open";
import { glob } from "tinyglobby";

//#region node_modules/.pnpm/tsdown@0.18.2_typescript@5.9.3/node_modules/tsdown/esm-shims.js
const getFilename = () => fileURLToPath(import.meta.url);
const getDirname = () => path.dirname(getFilename());
const __dirname$1 = /* @__PURE__ */ getDirname();

//#endregion
//#region src/config.ts
const findConfigFile = (cwd = process.cwd()) => {
	for (const ext of [
		"ts",
		"mts",
		"cts",
		"js",
		"mjs",
		"cjs"
	]) {
		const path$1 = resolve(cwd, `release.config.${ext}`);
		if (existsSync(path$1)) return path$1;
	}
};
const loadConfig = async (file) => {
	const { href } = pathToFileURL(file);
	const mod = await import(href);
	const temp = mod.default ?? mod;
	return typeof temp === "function" ? temp() : temp;
};
const resolveConfig = async (cwd, log$1) => {
	const configFile = findConfigFile(cwd);
	if (!configFile) return {};
	log$1?.(configFile);
	return loadConfig(configFile);
};
const toString = (self) => Object.prototype.toString.call(self);
const isPlainObject = (v) => toString(v) === "[object Object]";
const isFunction = (v) => toString(v) === "[object Function]";
const mergeConfig = (defaults, overrides) => {
	if (!overrides) return structuredClone(defaults);
	if (Object.keys(defaults).length === 0) return structuredClone(overrides);
	const result = {};
	for (const key in defaults) {
		const defaultValue = defaults[key];
		const overrideValue = overrides[key];
		if (overrideValue === void 0) if (isFunction(defaultValue)) result[key] = defaultValue;
		else result[key] = structuredClone(defaultValue);
		else if (isPlainObject(defaultValue) && isPlainObject(overrideValue)) result[key] = mergeConfig(defaultValue, overrideValue);
		else if (isFunction(overrideValue)) result[key] = overrideValue;
		else result[key] = structuredClone(overrideValue);
	}
	return result;
};

//#endregion
//#region src/utils.ts
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
function joinUrl(input) {
	const temps = Array.isArray(input) ? input : [...arguments];
	if (temps.length === 0) return "";
	const result = [];
	const parts = [...temps];
	/** åè®®æ­£åˆ™ */
	const PROTOCOL_RE = /^[^/:]+:\/*$/;
	const FILE_PROTOCOL_RE = /^file:\/\/\//;
	if (PROTOCOL_RE.test(parts[0]) && parts.length > 1) {
		parts[1] = parts[0] + parts[1];
		parts.shift();
	}
	if (FILE_PROTOCOL_RE.test(parts[0])) parts[0] = parts[0].replace(/^([^/:]+):\/*/, "$1:///");
	else parts[0] = parts[0].replace(/^([^/:]+):\/*/, "$1://");
	parts.forEach((part, index) => {
		if (!part) return;
		let segment = part;
		if (index > 0) segment = segment.replace(/^\/+/, "");
		if (index < parts.length - 1) segment = segment.replace(/\/+$/, "");
		else segment = segment.replace(/\/+$/, "/");
		result.push(segment);
	});
	let url = result.join("/");
	url = url.replace(/\/(\?|&|#[^!])/g, "$1");
	const [base, ...queryParts] = url.split("?");
	url = base + (queryParts.length ? "?" + queryParts.join("&") : "");
	return url;
}
const isUndefined = (val) => {
	return void 0 === val;
};
const eol = (n$1 = 1) => EOL.repeat(n$1);
const underline = (text$1) => {
	return styleText(["dim", "underline"], text$1);
};
const castArray = (arr) => {
	return Array.isArray(arr) ? arr : [arr];
};

//#endregion
//#region src/messages.ts
const n = (b) => {
	return b ? " (dry run)" : "";
};
const MSG = {
	INTRO: (pkgName, dryRun) => `ðŸš€  Starting release ${yellow(pkgName)}${n(dryRun)}`,
	OUTRO: (dryRun) => `ðŸŽ‰  Release finished successfully${n(dryRun)}`,
	LOG: {
		SHOW_VERSION: (version) => `ðŸŽ‰  Released ${green(version)}`,
		SHOW_CHANGELOG: "ðŸŽ‰  Changelog collected",
		CHANGELOG_EMPTY: "No commits found since last release",
		CHANGES_EMPTY: "Working tree clean. No files changed"
	},
	CHECK: {
		GIT: {
			CHECKING: "Checking Git repository",
			CHECKED: (name, url) => `Git remote resolved: ${dim(name)} â†’ ${underline(url)}`
		},
		NPM: {
			CHECKING: "Checking npm registry",
			CHECKED: (registry, msg$1) => `NPM registry: ${underline(registry)}${msg$1 ? ` ${msg$1}` : ""}`
		}
	},
	TASK: {
		VERSION: {
			START: "Bumping version",
			END: (version) => `Version bumped to ${green(version)}`
		},
		NPM: {
			START: "Publishing npm package",
			END: "NPM package published"
		},
		GIT: {
			START: "Creating git commit, tag & push",
			END: "Git commit, tag & push completed"
		},
		GITHUB: {
			START: "Creating GitHub release",
			END: "GitHub release created"
		}
	},
	PROMPT: {
		SELECT_VERSION: "Select version bump:",
		INPUT_VERSION: "Enter custom version:",
		NPM_PUBLISH: (pkg$1) => `Publish to npm ${underline(`(${pkg$1})`)}?`,
		NPM_OTP: "Enter npm one-time password (OTP):",
		GITHUB_RELEASE: (title) => `Create a new GitHub release ${underline(`(${title})`)}?`,
		GIT_COMMIT: (msg$1) => `Create git commit ${underline(`(${msg$1})`)}?`,
		GIT_TAG: (msg$1) => `Create git tag ${underline(`(${msg$1})`)}?`,
		GIT_PUSH: "Push commits and tags to remote?"
	},
	ERROR: {
		GIT_REGISTRY: (name) => `[git] Repository not found for ${dim(name)}`,
		GIT_REMOTE: (name) => `[git] Remote "${dim(name)}" not found`,
		GITHUB_TAG_EXIT: (tag) => `[github] Release or tag "${tag}" already exists`,
		GITHUB_TOKEN: (tokenRef) => `[github] Missing GitHub token. Please set ${yellow(tokenRef ?? "GITHUB_TOKEN")}`,
		GITHUB_AUTH: "[github] Invalid GitHub token or insufficient permissions",
		GITHUB_USER: "[github] User does not have permission to create releases",
		NPM_REGISTRY: (registry) => `[npm] Unable to reach npm registry ${underline(registry)}`,
		NPM_AUTH: `[npm] Not authenticated with npm. Please run ${yellow("npm login")} and try again.`,
		NPM_USER: (user, name) => `[npm] User ${dim(user)} is not a collaborator of ${dim(name)}.`
	}
};

//#endregion
//#region src/prompts.ts
const abortTask = (msg$1) => {
	cancel(`${red("âœ•")} ${msg$1}`);
	process.exit(0);
};
const abortOnCancel = (value) => {
	if (isCancel(value)) abortTask("Operation cancelled.");
};
const abortOnError = (err) => {
	const msg$1 = err.message.replace(/^\[(github|npm|git)]/, (a) => red(a));
	log.message(`\n${msg$1}\n`);
	process.exit(1);
};
const taskEnd = (msg$1) => {
	outro(msg$1);
	process.exit(0);
};
const msg = (prefix, msg$1) => {
	log.message(gray`${rgb(33, 91, 184)(`[${prefix}]`)} ${msg$1}`);
};
const prompt = (msg$1) => {
	return `${blue`?`} ${msg$1}`;
};

//#endregion
//#region src/version/bump.ts
const isPreRelease = (version) => {
	return Boolean(prerelease(version));
};
const isValid = (version) => {
	return Boolean(valid(version));
};
const parseVersion = (raw) => {
	const next = isValid(raw) ? raw : coerce(raw)?.toString();
	if (!next) return {};
	const { prerelease: prerelease$1 } = parse(next);
	const toPreRelease = Boolean(prerelease$1.length);
	const [preId, preBase] = prerelease$1.map(String);
	return {
		next,
		toPreRelease,
		preId,
		preBase
	};
};
const getCIVersion = (current) => {
	return inc(current, Release.PATCH);
};

//#endregion
//#region src/version/prompts.ts
let Release = /* @__PURE__ */ function(Release$1) {
	Release$1["MAJOR"] = "major";
	Release$1["MINOR"] = "minor";
	Release$1["PATCH"] = "patch";
	return Release$1;
}({});
let PreRelease = /* @__PURE__ */ function(PreRelease$1) {
	PreRelease$1["MAJOR"] = "premajor";
	PreRelease$1["MINOR"] = "preminor";
	PreRelease$1["PATCH"] = "prepatch";
	PreRelease$1["RELEASE"] = "prerelease";
	return PreRelease$1;
}({});
let PreId = /* @__PURE__ */ function(PreId$1) {
	PreId$1["ALPHA"] = "alpha";
	PreId$1["BETA"] = "beta";
	PreId$1["RC"] = "rc";
	PreId$1["NET"] = "next";
	PreId$1["CANARY"] = "canary";
	PreId$1["NIGHT"] = "nightly";
	PreId$1["DEV"] = "dev";
	return PreId$1;
}({});
const diff = (from, to) => {
	const a = from.split(".");
	return to.split(".").map((v, i) => v === a[i] ? dim(v) : green(v)).join(".");
};
const runVersionPrompts = async (ctx, config) => {
	const { pkg: { current, fromPreRelease } } = ctx;
	const selectVersion = async () => {
		const patch = inc(current, Release.PATCH);
		const minor = inc(current, Release.MINOR);
		const major = inc(current, Release.MAJOR);
		const prerelease$1 = inc(current, PreRelease.RELEASE);
		const prepatch = inc(current, PreRelease.PATCH, PreId.BETA);
		const preminor = inc(current, PreRelease.MINOR, PreId.BETA);
		const premajor = inc(current, PreRelease.MAJOR, PreId.BETA);
		const pr = [{
			label: "Pre-Release",
			value: prerelease$1,
			hint: prerelease$1
		}];
		const pre = [
			{
				label: "Pre-Patch",
				value: prepatch,
				hint: prepatch
			},
			{
				label: "Pre-Minor",
				value: preminor,
				hint: preminor
			},
			{
				label: "Pre-Major",
				value: premajor,
				hint: premajor
			}
		];
		const release = [
			{
				label: "Patch",
				value: patch,
				hint: patch
			},
			{
				label: "Minor",
				value: minor,
				hint: minor
			},
			{
				label: "Major",
				value: major,
				hint: major
			}
		];
		const custom = [{
			label: "As-Is",
			value: "ignore",
			hint: current
		}, {
			label: "Custom",
			value: "custom",
			hint: "custom specified"
		}];
		const version = await select({
			message: prompt(MSG.PROMPT.SELECT_VERSION),
			options: [
				...fromPreRelease ? pr : [],
				...release,
				...fromPreRelease ? [] : pre,
				...custom
			],
			initialValue: fromPreRelease ? prerelease$1 : patch
		});
		abortOnCancel(version);
		return version;
	};
	const inputVersion = async () => {
		const version = await text({
			message: prompt(MSG.PROMPT.INPUT_VERSION),
			initialValue: current,
			validate: (val) => {
				if (!isValid(val)) return "Invalid version";
			}
		});
		abortOnCancel(version);
		return version;
	};
	const type = await selectVersion();
	const next = type === "custom" ? await inputVersion() : type === "ignore" ? current : type;
	const parsed = parseVersion(next);
	Object.assign(ctx.pkg, { ...parsed });
	ctx.isIncrement = gte(next, current);
	log.message(gray`
    from ${dim(current)}
      to ${diff(current, next)}
  `);
	return { next };
};

//#endregion
//#region src/defaults.ts
const createDefaultContext = () => {
	return {
		ci: false,
		release: false,
		noNpm: false,
		dryRun: false,
		changelog: false,
		increment: "",
		isIncrement: false,
		noGithub: false,
		pkg: {
			current: "",
			next: "",
			name: "",
			isPrivate: false,
			fromPreRelease: false,
			toPreRelease: false,
			publishConfig: {
				access: "public",
				registry: "https://registry.npmjs.org",
				publicPath: ""
			},
			preId: PreId.BETA,
			preBase: "0"
		},
		npm: {
			username: "",
			otp: ""
		},
		git: {
			remoteName: "origin",
			remoteUrl: "",
			latestTag: "",
			previousTag: "",
			currentTag: "",
			isCommitted: false,
			isTagged: false
		},
		github: {
			username: "",
			repo: "",
			changelog: "",
			owner: "",
			isWeb: false,
			skipChecks: false,
			isReleased: false,
			releaseId: 0,
			releaseUrl: "",
			uploadUrl: "",
			discussionUrl: "",
			token: ""
		}
	};
};
const createDefaultConfig = (isCI) => {
	return {
		hooks: {
			"before:bump": "",
			"after:bump": "",
			"before:publish": "",
			"after:publish": "",
			"before:push": "",
			"after:push": "",
			"before:release": "",
			"after:release": ""
		},
		git: {
			commit: isCI,
			tag: isCI,
			push: isCI,
			commitMessage: "chore(release): ${version}",
			tagMessage: "Release ${version}",
			tagName: "${version}"
		},
		npm: {
			publish: isCI,
			tag: "",
			allowSameVersion: false
		},
		github: {
			release: isCI,
			releaseName: "Release ${version}",
			prerelease: false,
			draft: false,
			tokenRef: "GITHUB_TOKEN",
			assets: []
		}
	};
};

//#endregion
//#region src/git/commit.ts
const getBranchName = () => {
	return runGit([
		"rev-parse",
		"--abbrev-ref",
		"HEAD"
	]);
};
const getRemoteForBranch = (branch) => {
	return runGit([
		"config",
		"--get",
		`branch.${branch}.remote`
	]);
};
const getStatus = () => {
	return runGit([
		"status",
		"--short",
		"--untracked-files=no"
	], false);
};
const gitRestore = () => {
	return runGit(["restore", "."]);
};
const coloredChangeset = (log$1) => {
	const colorStatusChar = (ch) => {
		switch (ch) {
			case "M": return `\x1b[33m${ch}\x1b[0m`;
			case "A": return `\x1b[32m${ch}\x1b[0m`;
			case "D": return `\x1b[31m${ch}\x1b[0m`;
			default: return ch;
		}
	};
	const colorStatus = (status) => status.split("").map(colorStatusChar).join("");
	return log$1.split("\n").filter(Boolean).map((line) => {
		const status = line.slice(0, 2);
		const file = line.slice(3);
		return `${colorStatus(status)} ${styleText(["dim"], file)}`;
	}).join("\n");
};
const getRemote = async () => {
	const branch = await getBranchName();
	const remoteName = branch && await getRemoteForBranch(branch) || "origin";
	return {
		remoteName,
		remoteUrl: await runGit([
			"remote",
			"get-url",
			remoteName
		]).catch((_) => runGit([
			"config",
			"--get",
			`remote.${remoteName}.url`
		]))
	};
};
const getLatestTag = async (match = "*", exclude = "*-beta.*") => {
	return runGit([
		"describe",
		"--tags",
		"--abbrev=0",
		`--match=${match}`,
		`--exclude=${exclude}`
	]);
};
const getPreviousTag = async (current) => {
	return runGit([
		"describe",
		"--tags",
		"--abbrev=0",
		`${await runGit([
			"rev-list",
			"--tags",
			current || "--skip=1",
			"--max-count=1"
		])}^`
	]);
};
const resolveChangelogRange = async (isIncrement) => {
	const latestTag = await getLatestTag();
	const previousTag = await getPreviousTag(latestTag);
	if (!latestTag) return {
		from: "",
		to: "HEAD"
	};
	if (!isIncrement && previousTag) return {
		from: previousTag,
		to: `${latestTag}^1`
	};
	return {
		from: latestTag,
		to: "HEAD"
	};
};
const getLog = async (print, isIncrement) => {
	const cmd = ["log", `--pretty=format:${print ? "* %s (%h)" : "%s %h %H"}`];
	const { from, to } = await resolveChangelogRange(isIncrement);
	if (from) cmd.push(`${from}...${to}`);
	return runGit(cmd, false);
};
const normalizeTag = (tag) => clean(tag) ?? tag;
const resolveTag$1 = async (ctx, config) => {
	const { git: { tagName: tagTemplate } } = config;
	const latestTag = await getLatestTag() ?? "";
	const currentTag = format(tagTemplate || ((latestTag || "").match(/^v/) ? "v${version}" : "${version}"), ctx);
	Object.assign(ctx.git, {
		latestTag,
		currentTag
	});
	return true;
};
const gitCheck = async (ctx, config) => {
	const { pkg: { name } } = ctx;
	if (!await isGitRepo()) throw new Error(MSG.ERROR.GIT_REGISTRY(name));
	const { remoteName, remoteUrl } = await getRemote();
	if (!remoteUrl) throw new Error(MSG.ERROR.GIT_REMOTE(name));
	Object.assign(ctx.git, {
		remoteName,
		remoteUrl
	});
	parseGithubUrl(ctx);
};
const hasUpstreamBranch = async () => {
	const branch = await runGit([
		"for-each-ref",
		"--format=%(upstream:short)",
		await runGit(["symbolic-ref", "HEAD"])
	]);
	return Boolean(branch);
};
const getUpstreamArgs = async (remoteName) => {
	const hasUpstream = await hasUpstreamBranch();
	const branch = await getBranchName();
	if (!hasUpstream) return remoteName ? [
		"--set-upstream",
		remoteName,
		branch
	] : [
		"--set-upstream",
		"origin",
		branch
	];
	if (remoteName) return [remoteName];
	return [];
};
const format = (str, ctx) => {
	const { pkg: { next } } = ctx;
	return str.replace("${version}", next);
};
const commitAndTag = async (ctx, config) => {
	const { git: { currentTag, remoteName }, dryRun } = ctx;
	const { git: { commit, tag, push, tagMessage, commitMessage } } = config;
	if (!commit) return;
	const args = dryRun ? ["--dry-run"] : [];
	await runGit([
		"add",
		".",
		"--all",
		...args
	]);
	await runGit([
		"commit",
		"--message",
		format(commitMessage, ctx),
		...args
	]);
	if (!dryRun) Object.assign(ctx.git, { isCommitted: true });
	if (tag) {
		await runGit([
			"tag",
			"--annotate",
			"--message",
			format(tagMessage, ctx),
			currentTag,
			...args
		]);
		if (!dryRun) Object.assign(ctx.git, { isTagged: true });
	}
	if (push) await runGit([
		"push",
		...await getUpstreamArgs(remoteName),
		"--follow-tags",
		...args
	]);
};
const gitRollback = async (ctx) => {
	const { git: { currentTag, isCommitted, isTagged } } = ctx;
	await gitRestore();
	if (isTagged) await runGit([
		"tag",
		"--delete",
		currentTag
	]);
	await runGit([
		"reset",
		"--hard",
		isCommitted ? "HEAD~1" : "HEAD"
	]);
};

//#endregion
//#region src/github/release.ts
const getGithubUrl = (owner, repo) => {
	return `https://github.com/${owner}/${repo}`;
};
const truncateBody = (body) => {
	if (body && body.length >= 124e3) return body.substring(0, 124e3) + "...";
	return body;
};
const uploadAssets = async (ctx, config) => {
	const { github: { assets } } = config;
	const { github: { isReleased, owner, repo, uploadUrl, releaseId, token }, pkg: { name } } = ctx;
	if (!assets?.length || !isReleased) return;
	const octokit = new Octokit({ auth: token });
	const files = await glob(assets);
	await Promise.all(files.map((file) => {
		return octokit.repos.uploadReleaseAsset({
			owner,
			repo,
			name,
			url: uploadUrl,
			release_id: releaseId,
			data: createReadStream(file),
			headers: {
				"content-type": contentType(file) || "application/octet-stream",
				"content-length": statSync(file).size
			}
		});
	}));
};
const createWebRelease = async (ctx, config) => {
	const { pkg: { next, toPreRelease }, github: { owner, repo, changelog } } = ctx;
	const { github: { prerelease: prerelease$1, releaseName } } = config;
	const github = getGithubUrl(owner, repo);
	const url = new URL(`${github}/releases/new`);
	url.searchParams.set("tag", next);
	url.searchParams.set("title", format(releaseName, ctx) ?? `Release ${next}`);
	url.searchParams.set("body", truncateBody(changelog));
	url.searchParams.set("prelease", String(toPreRelease || prerelease$1));
	const isWindows = process.platform === "win32";
	await open(url.toString(), { wait: isWindows });
};
const createCiRelease = async (ctx, config) => {
	const { pkg: { next, toPreRelease }, github: { owner, repo, token, changelog } } = ctx;
	const { github: { prerelease: prerelease$1, releaseName, draft } } = config;
	const octokit = new Octokit({ auth: token });
	try {
		const { data } = await octokit.repos.createRelease({
			owner,
			repo,
			tag_name: next,
			name: format(releaseName, ctx) ?? `Release ${next}`,
			body: truncateBody(changelog),
			draft: draft ?? false,
			prerelease: (toPreRelease || prerelease$1) ?? false
		});
		const { html_url, upload_url, id, discussion_url } = data;
		Object.assign(ctx.github, {
			isReleased: true,
			releaseId: id,
			releaseUrl: html_url,
			uploadUrl: upload_url,
			discussionUrl: discussion_url
		});
	} catch (e) {
		if (e?.status === 422) throw new Error(MSG.ERROR.GITHUB_TAG_EXIT(next));
		throw e;
	}
};
const parseGithubUrl = (ctx) => {
	const { git: { remoteUrl } } = ctx;
	const [owner, repo] = parseGitHubRepo(remoteUrl);
	Object.assign(ctx.github, {
		owner,
		repo
	});
};
const createRelease = async (ctx, config) => {
	const { github: { owner, repo, skipChecks }, ci } = ctx;
	const { github: { tokenRef, release } } = config;
	if (!release) return;
	const token = tokenRef ? process.env[tokenRef] : process.env.GITHUB_TOKEN;
	if (!token) {
		Object.assign(ctx.github, { isWeb: true });
		if (ci && process.env.GITHUB_ACTIONS) throw new Error(MSG.ERROR.GITHUB_TOKEN(tokenRef));
	}
	Object.assign(ctx.github, { token });
	const octokit = new Octokit({ auth: token });
	if (token && !skipChecks) if (process.env.GITHUB_ACTIONS) Object.assign(ctx.github, { username: process.env.GITHUB_ACTOR });
	else {
		try {
			const { data: { login: username } } = await octokit.users.getAuthenticated();
			Object.assign(ctx.github, { username });
		} catch (e) {
			throw new Error(MSG.ERROR.GITHUB_AUTH);
		}
		try {
			const { github: { username } } = ctx;
			await octokit.repos.checkCollaborator({
				owner,
				repo,
				username
			});
		} catch (e) {
			throw new Error(MSG.ERROR.GITHUB_USER);
		}
	}
	const { github: { isWeb }, dryRun } = ctx;
	if (dryRun) return true;
	if (isWeb) await createWebRelease(ctx, config);
	else if (ci) {
		await createCiRelease(ctx, config);
		await uploadAssets(ctx, config);
	}
};
const getGithubReleaseUrl = (ctx) => {
	const { github: { owner, repo }, git: { currentTag } } = ctx;
	return `${getGithubUrl(owner, repo)}/releases/tag/${normalizeTag(currentTag)}`;
};

//#endregion
//#region src/git/changetype.ts
const defaultTypes = [
	{
		type: "feat",
		section: "âœ¨ æ–°åŠŸèƒ½",
		description: "æ–°å¢žåŠŸèƒ½"
	},
	{
		type: "fix",
		section: "ðŸ› Bug ä¿®å¤",
		description: "ä¿®å¤ bug"
	},
	{
		type: "chore",
		section: "ðŸŽ« å…¶ä»–æ›´æ–°",
		description: "éžåŠŸèƒ½æ€§æ›´æ”¹"
	},
	{
		type: "docs",
		section: "ðŸ“ æ–‡æ¡£",
		description: "æ–‡æ¡£æ›´æ–°"
	},
	{
		type: "style",
		section: "ðŸ’„ æ ·å¼è°ƒæ•´",
		description: "æ ·å¼æˆ–æ ¼å¼ä¿®æ”¹"
	},
	{
		type: "refactor",
		section: "â™» ä»£ç é‡æž„",
		description: "é‡æž„ä»£ç "
	},
	{
		type: "perf",
		section: "âš¡ æ€§èƒ½ä¼˜åŒ–",
		description: "æå‡æ€§èƒ½"
	},
	{
		type: "test",
		section: "âœ… æµ‹è¯•",
		description: "æµ‹è¯•æ›´æ–°"
	},
	{
		type: "revert",
		section: "âª å›žé€€",
		description: "å›žé€€åˆ°ä¹‹å‰ç‰ˆæœ¬"
	},
	{
		type: "build",
		section: "ðŸ‘·â€ æž„å»ºç³»ç»Ÿ",
		description: "æž„å»ºå·¥å…·å’Œç³»ç»Ÿä¿®æ”¹"
	},
	{
		type: "ci",
		section: "ðŸ”§ CI é…ç½®",
		description: "æŒç»­é›†æˆé…ç½®"
	},
	{
		type: "config",
		section: "ðŸ”¨ é…ç½®",
		description: "é…ç½®æ–‡ä»¶æ›´æ–°"
	},
	{
		type: "deps",
		section: "ðŸ”— ä¾èµ–æ›´æ–°",
		description: "ä¾èµ–ç‰ˆæœ¬å˜æ›´"
	},
	{
		type: "security",
		section: "ðŸ”’ å®‰å…¨ä¿®å¤",
		description: "å®‰å…¨æ€§æ›´æ–°"
	},
	{
		type: "i18n",
		section: "ðŸŒ å›½é™…åŒ–",
		description: "å›½é™…åŒ–ç›¸å…³æ›´æ–°"
	},
	{
		type: "ux",
		section: "ðŸ–¥ï¸ ç”¨æˆ·ä½“éªŒ",
		description: "ç”¨æˆ·ä½“éªŒæ”¹è¿›"
	},
	{
		type: "hotfix",
		section: "ðŸ”¥ çƒ­ä¿®å¤",
		description: "ç´§æ€¥ä¿®å¤"
	},
	{
		type: "break",
		section: "ðŸ’¥ ç ´åæ€§å˜æ›´",
		description: "ç ´åæ€§å˜æ›´"
	}
];
const findType = (type) => {
	return defaultTypes.find((item) => item.type === type)?.section ?? type;
};

//#endregion
//#region src/git/changelog.ts
const getCommits = async (isIncrement) => {
	return (await getLog(false, isIncrement))?.split("\n").filter(Boolean);
};
const parseCommit = (message) => {
	const match = message.match(/^(\w+):\s(.+)\s(\w{7})\s(\w{40})$/);
	if (!match) return;
	return {
		type: match[1],
		description: match[2],
		hash: match[3],
		fullHash: match[4]
	};
};
const classify = (commits) => {
	const sections = {};
	for (const msg$1 of commits) {
		const parsed = parseCommit(msg$1);
		if (!parsed) continue;
		const { type, description, hash, fullHash } = parsed;
		(sections[type] ??= []).push([
			description,
			hash,
			fullHash
		]);
	}
	return sections;
};
const renderChangelog = async (ctx, sections) => {
	const { pkg: { next: to }, github: { owner, repo }, git: { latestTag } } = ctx;
	const date = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
	const github = getGithubUrl(owner, repo);
	const eol$1 = (n$1) => EOL.repeat(n$1);
	let md;
	if (!latestTag) md = `## ${to} (${date})${eol$1(2)}`;
	else md = `## [${to}](${github}/compare/${latestTag}...${to}) (${date})${eol$1(2)}`;
	for (const [type, items] of Object.entries(sections)) {
		if (!items.length) continue;
		md += `### ${findType(type)}${eol$1(2)}`;
		for (const [desc, hash, fullHash] of items) md += `* **${type}** ${desc} [${hash}](${github}/commit/${fullHash})${eol$1(1)}`;
		md += eol$1(2);
	}
	if (latestTag) {
		md += `**Full Changelog**: ${github}/compare/${latestTag}...${to}`;
		md += eol$1(3);
	}
	return md;
};
const generateChangelog = async (ctx) => {
	const { isIncrement } = ctx;
	const commits = await getCommits(isIncrement);
	if (!commits) return "";
	const changelog = await renderChangelog(ctx, classify(commits));
	Object.assign(ctx.github, { changelog });
	return changelog;
};
const updateChangelog = async (newContent) => {
	const file = "CHANGELOG.md";
	const title = `# Changelog${eol(3)}`;
	await writeFile(file, `${(existsSync(file) && await readFile(file, "utf-8") || title).replace(/* @__PURE__ */ new RegExp(`^${title}`), `${title}${newContent}`).trim()}${eol()}`);
	await runGit(["add", file]);
};

//#endregion
//#region src/git/prompts.ts
const runGitPrompts = async (ctx, config) => {
	const { git: { currentTag }, configFileExists: cfe, dryRun } = ctx;
	const { git: { commit, tag, push, commitMessage } } = config;
	const logs = [];
	const cMsg = format(commitMessage, ctx);
	const shouldPrompt = (val) => isUndefined(val) || dryRun;
	const { log: _, ...reset } = await group({
		commit: () => {
			return shouldPrompt(commit) ? confirm({ message: prompt(MSG.PROMPT.GIT_COMMIT(cMsg)) }) : (() => {
				logs.push(yellow`git.commit`);
				return Promise.resolve(commit);
			})();
		},
		tag: () => {
			return shouldPrompt(tag) ? confirm({ message: prompt(MSG.PROMPT.GIT_TAG(currentTag)) }) : (() => {
				logs.push(yellow`git.tag`);
				return Promise.resolve(tag);
			})();
		},
		push: () => {
			return shouldPrompt(push) ? confirm({ message: prompt(MSG.PROMPT.GIT_PUSH) }) : (() => {
				logs.push(yellow`git.push`);
				return Promise.resolve(push);
			})();
		},
		log: () => {
			if (logs.length) msg("GIT", `Using ${cfe ? "user" : "default"} config: ${logs.join(", ")}`);
			return Promise.resolve();
		}
	}, { onCancel: async ({ results }) => {
		await gitRollback(ctx);
		abortTask("Operation cancelled.");
	} });
	Object.assign(config.git, reset);
};

//#endregion
//#region src/github/prompts.ts
const runGithubPrompts = async (ctx, config) => {
	const { configFileExists: cfe, dryRun } = ctx;
	const { github: { release, releaseName } } = config;
	const logs = [];
	const title = format(releaseName, ctx);
	const shouldPrompt = (val) => isUndefined(val) || dryRun;
	const res = await group({
		release: () => shouldPrompt(release) ? confirm({ message: prompt(MSG.PROMPT.GITHUB_RELEASE(title)) }) : (() => {
			logs.push(yellow`github.release`);
			return Promise.resolve(release);
		})(),
		log: () => {
			if (logs.length) msg("GITHUB", `Using ${cfe ? "user" : "default"} config: ${logs.join(", ")}`);
			return Promise.resolve();
		}
	}, { onCancel: async ({ results }) => {
		await gitRollback(ctx);
		abortTask("Operation cancelled.");
	} });
	Object.assign(config.github, { release: res.release });
	return res;
};

//#endregion
//#region src/npm/prompts.ts
const runNpmPublishPrompts = async (ctx, config) => {
	const { pkg: { name, next }, configFileExists: cfe, dryRun } = ctx;
	const { npm: { publish } } = config;
	const logs = [];
	const target = `${name}@${next}`;
	const shouldPrompt = (val) => isUndefined(val) || dryRun;
	const res = await group({
		publish: () => shouldPrompt(publish) ? confirm({ message: prompt(MSG.PROMPT.NPM_PUBLISH(target)) }) : (() => {
			logs.push(yellow`npm.publish`);
			return Promise.resolve(publish);
		})(),
		log: () => {
			if (logs.length) msg("NPM", `Using ${cfe ? "user" : "default"} config: ${logs.join(", ")}`);
			return Promise.resolve();
		}
	}, { onCancel: async ({ results }) => {
		await gitRollback(ctx);
		abortTask("Operation cancelled.");
	} });
	Object.assign(config.npm, { publish: res.publish });
	return res;
};
const runNpmOptPrompts = async (ctx, config) => {
	const res = await group({ otp: () => text({ message: MSG.PROMPT.NPM_OTP }) }, { onCancel: async ({ results }) => {
		await gitRollback(ctx);
		abortTask("Operation cancelled.");
	} });
	Object.assign(ctx.npm, { otp: res.otp });
	return res;
};

//#endregion
//#region src/npm/publish.ts
const DEFAULT_TAG = "latest";
const DEFAULT_TAG_PRERELEASE = "next";
const getRegistry = (publishConfig = {}) => {
	return (publishConfig.registry ? [publishConfig.registry] : Object.keys(publishConfig).filter((key) => key.endsWith("registry")).map((key) => publishConfig[key]))[0];
};
const isRegistryUp = async (registry) => {
	return void 0 !== await runNpm(["ping", ...registry ? [`--registry ${registry}`] : []]);
};
const isAuthenticated = (registry) => {
	return runNpm(["whoami", ...registry ? [`--registry ${registry}`] : []]);
};
const getLatestRegistryVersion = (name, tag, registry) => {
	const registryArg = registry ? [`--registry ${registry}`] : [];
	return runNpm([
		"show",
		`${name}@${tag}`,
		"version",
		...registryArg
	]);
};
const getRegistryTags = async (name, registry) => {
	const res = await runNpm([
		"view",
		name,
		"dist-tags",
		"--json",
		...registry ? [`--registry ${registry}`] : []
	]);
	return Object.keys(JSON.parse(res || "{}"));
};
const bump = (version, allowSameVersion, args = []) => {
	allowSameVersion && args.push(`--allow-same-version`);
	return runNpm([
		"version",
		version,
		"--no-git-tag-version",
		"--workspaces=false",
		...args
	]);
};
const guessPreReleaseTag = async (name) => {
	return (await getRegistryTags(name)).filter((tag) => DEFAULT_TAG !== tag)[0] ?? DEFAULT_TAG_PRERELEASE;
};
const resolveTag = async (ctx, config) => {
	const { npm: { tag } } = config;
	const { pkg: { name, current } } = ctx;
	const { toPreRelease, preId } = parseVersion(current);
	if (!toPreRelease) return DEFAULT_TAG;
	else return tag || preId || await guessPreReleaseTag(name);
};
const isCollaborator = async (ctx) => {
	const { pkg: { name, publishConfig }, npm: { username } } = ctx;
	const registry = getRegistry(publishConfig);
	const registryArg = registry ? [`--registry ${registry}`] : [];
	let npmVersion = await runNpm(["--version"]);
	let accessCommand;
	if (gt(npmVersion, "9.0.0")) accessCommand = [
		"access",
		"list",
		"collaborators",
		"--json"
	];
	else accessCommand = ["access", "ls-collaborators"];
	const res = await runNpm([
		...accessCommand,
		name,
		...registryArg
	]);
	if (res) {
		const permissions = JSON.parse(res ?? "{}")[username];
		return permissions && permissions.includes("write");
	}
	log.error(`Unable to verify if user ${username} is a collaborator for ${name}.`);
};
const getPackageUrl = (ctx) => {
	const { name } = ctx.pkg;
	return joinUrl([
		"https://www.npmjs.com",
		"/package",
		name
	]);
};
const npmCheck = async (ctx, config) => {
	const { pkg: { name, publishConfig }, npm: { username } } = ctx;
	const registry = getRegistry(publishConfig);
	const tag = await resolveTag(ctx, config);
	const getUser = async () => {
		const username$1 = await isAuthenticated(registry);
		if (!username$1) return false;
		Object.assign(ctx.npm, { username: username$1.trim() });
		return true;
	};
	if (!await isRegistryUp()) throw new Error(MSG.ERROR.NPM_REGISTRY(registry));
	if (!await getUser()) throw new Error(MSG.ERROR.NPM_AUTH);
	const latestPublish = await getLatestRegistryVersion(name, tag, registry);
	if (latestPublish) {
		if (!await isCollaborator(ctx)) throw new Error(MSG.ERROR.NPM_USER(username, name));
	}
	return dim(latestPublish ? `(latest is ${latestPublish.trim()})` : "(new publish)");
};
const isOtpError = (err) => /one-time password|otp/i.test(err.message);
const publishNpm = async (ctx, config) => {
	const { dryRun, npm: { otp } } = ctx;
	const { npm: { publish, tag } } = config;
	if (!publish) return;
	const args = ["publish"];
	if (tag) args.push("--tag", tag);
	if (otp) args.push("--otp", otp);
	if (dryRun) args.push("--dry-run");
	return runNpm(args);
};

//#endregion
//#region src/action.ts
const info = (msg$1) => {
	console.log(`${rgb(33, 91, 184)(`â„¹`)} ${gray(msg$1)}`);
};
const success = (msg$1, dryRun) => {
	return `${(dryRun ? rgb(123, 115, 66) : green)("âœ”")} ${msg$1}`;
};
const runLifeCycleHook = async (hooks, key, dryRun) => {
	const handler = hooks[key];
	if (typeof handler === "function") {
		if (!dryRun) await handler();
		log.success(success(`${dim`run`} ${inspect(handler)}`, dryRun));
		return;
	}
	return Promise.allSettled(castArray(handler).map(async (hook) => {
		if (!dryRun) await execAsync(hook, { shell: true }).catch(console.error);
		handler && log.success(success(hook.replace("echo", dim("echo")), dryRun));
	}));
};
var Action = class {
	async handle(cmdArgs, options) {
		const { version: cVersion, name: cName } = readJsonFile(join(__dirname$1, "../package.json"));
		info(`${cName} ${dim(`v${cVersion}`)} `);
		const { otp, ...others } = options;
		const { showChangelog, showRelease, ci, dryRun } = Object.fromEntries(Object.entries(others).map(([k, v]) => [k, Boolean(v)]));
		const { version: pkgVersion, private: pkgPrivate, name: pkgName, publishConfig = {} } = readJsonFile("package.json");
		const nextVersion = inc(pkgVersion, cmdArgs) ?? "";
		const local = await resolveConfig(process.cwd(), (path$1) => {
			info(`config file: ${underline(path$1)}`);
		});
		const config = mergeConfig(createDefaultConfig(ci ? true : void 0), local);
		const ctx = mergeConfig(createDefaultContext(), {
			configFileExists: Object.keys(local).length > 0,
			dryRun,
			npm: { otp: String(otp) },
			increment: cmdArgs,
			isIncrement: true,
			ci: [
				ci,
				showChangelog,
				showRelease,
				process.env.GITHUB_ACTIONS,
				process.env.CI
			].some((k) => Boolean(k)),
			pkg: {
				name: pkgName,
				isPrivate: pkgPrivate,
				fromPreRelease: isPreRelease(pkgVersion),
				current: pkgVersion,
				next: "",
				toPreRelease: false,
				publishConfig: { ...publishConfig }
			}
		});
		console.log();
		intro(MSG.INTRO(pkgName, dryRun));
		const { hooks } = config;
		await tasks([{
			title: MSG.CHECK.GIT.CHECKING,
			task: async () => {
				await gitCheck(ctx, config);
				const { git: { remoteName, remoteUrl } } = ctx;
				return success(MSG.CHECK.GIT.CHECKED(remoteName, remoteUrl), dryRun);
			}
		}, {
			title: MSG.CHECK.NPM.CHECKING,
			task: async () => {
				const msg$1 = await npmCheck(ctx, config);
				const { pkg: { publishConfig: { registry } } } = ctx;
				return success(MSG.CHECK.NPM.CHECKED(registry, msg$1), dryRun);
			}
		}]).catch(abortOnError);
		{
			const { pkg: { current, next }, isIncrement, ci: ci$1 } = ctx;
			if (ci$1) {
				if (!next && isIncrement) {
					const next$1 = nextVersion || getCIVersion(current);
					if (next$1) {
						const parsed = parseVersion(next$1);
						Object.assign(ctx.pkg, { ...parsed });
					}
				}
				if (showRelease) {
					const { pkg: { next: next$1 } } = ctx;
					taskEnd(MSG.LOG.SHOW_VERSION(next$1));
				}
			}
		}
		{
			const logStr = await getLog(true, ctx.isIncrement);
			if (logStr) {
				msg("GIT", `Changelog:${eol(2)}` + dim(logStr));
				if (showChangelog) taskEnd(MSG.LOG.SHOW_CHANGELOG);
			} else msg("GIT", MSG.LOG.CHANGELOG_EMPTY);
		}
		{
			const { pkg: { next }, isIncrement } = ctx;
			if (!next && isIncrement) await runVersionPrompts(ctx, config);
			await runLifeCycleHook(hooks, "before:bump", dryRun);
			await tasks([{
				title: MSG.TASK.VERSION.START,
				task: async () => {
					const { pkg: { next: next$1 }, isIncrement: isIncrement$1 } = ctx;
					await bump(next$1, isIncrement$1);
					await resolveTag$1(ctx, config);
					await updateChangelog(await generateChangelog(ctx));
					return success(MSG.TASK.VERSION.END(next$1), dryRun);
				}
			}]).catch(abortOnError);
			await runLifeCycleHook(hooks, "after:bump", dryRun);
		}
		{
			const changeset = await getStatus();
			if (changeset) msg("GIT", `Changes:${eol(2)}` + coloredChangeset(changeset));
			else msg("GIT", MSG.LOG.CHANGES_EMPTY);
		}
		{
			const { pkg: { isPrivate }, ci: ci$1 } = ctx;
			if (!isPrivate) {
				await runNpmPublishPrompts(ctx, config);
				await runLifeCycleHook(hooks, "before:publish", dryRun);
				await tasks([{
					title: MSG.TASK.NPM.START,
					task: async () => {
						await publishNpm(ctx, config).catch(async (err) => {
							if (isOtpError(err) && !ci$1) {
								await runNpmOptPrompts(ctx, config);
								await publishNpm(ctx, config);
							} else throw err;
						});
						const url = getPackageUrl(ctx);
						return success(MSG.TASK.NPM.END + `: ${url}`, dryRun);
					}
				}]).catch(abortOnError);
				await runLifeCycleHook(hooks, "after:publish", dryRun);
			}
		}
		await runGitPrompts(ctx, config);
		await runLifeCycleHook(hooks, "before:push", dryRun);
		await tasks([{
			title: MSG.TASK.GIT.START,
			task: async () => {
				await commitAndTag(ctx, config);
				return success(MSG.TASK.GIT.END, dryRun);
			}
		}]).catch(abortOnError);
		await runLifeCycleHook(hooks, "after:push", dryRun);
		await runGithubPrompts(ctx, config);
		await runLifeCycleHook(hooks, "before:release", dryRun);
		await tasks([{
			title: MSG.TASK.GITHUB.START,
			task: async () => {
				await createRelease(ctx, config);
				const url = getGithubReleaseUrl(ctx);
				return success(MSG.TASK.GITHUB.END + `: ${url}`, dryRun);
			}
		}]).catch(abortOnError);
		await runLifeCycleHook(hooks, "after:release", dryRun);
		if (dryRun) await gitRollback(ctx);
		taskEnd(MSG.OUTRO(dryRun));
	}
};

//#endregion
//#region src/cli.ts
const pkg = readJsonFile(join(__dirname, "..", "package.json"));
program.name(pkg.name).description(pkg.description).version(pkg.version, "-v, --version", "Output the current version.").usage("[ARGUMENT] [OPTION]...").argument("[argument]", "patch|minor|major").option("-n, --dry-run", "Report actions that would be performed without writing out results.", false).option("--ci", "CI mode", false).option("--otp", "npm publish otp", "").option("--show-changelog", "Skip npm publish", false).option("--show-release", "Skip github release", false).action(async (argName, options) => {
	await new Action().handle(argName, options);
}).helpOption("-h, --help", "Output usage information.").parse(process.argv);
program.on("command:*", () => {
	console.error(`\n${red`Error`} Invalid command: ${red`%s`}`, program.args.join(" "));
	console.log(`See ${red`--help`} for a list of available commands.\n`);
	process.exit(1);
});

//#endregion
export {  };