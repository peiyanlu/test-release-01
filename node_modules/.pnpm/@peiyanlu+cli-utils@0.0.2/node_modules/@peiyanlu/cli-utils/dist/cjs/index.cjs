let node_child_process = require("node:child_process");
let node_fs = require("node:fs");
let node_fs_promises = require("node:fs/promises");
let node_path = require("node:path");
let node_util = require("node:util");

//#region src/enums.ts
let PkgManager = /* @__PURE__ */ function(PkgManager$1) {
	PkgManager$1["NPM"] = "npm";
	PkgManager$1["YARN"] = "yarn";
	PkgManager$1["PNPM"] = "pnpm";
	return PkgManager$1;
}({});
/**
* @deprecated Use `ConfirmResult` instead.
*/
let YesOrNo = /* @__PURE__ */ function(YesOrNo$1) {
	YesOrNo$1["Yes"] = "yes";
	YesOrNo$1["No"] = "no";
	YesOrNo$1["Ignore"] = "ignore";
	return YesOrNo$1;
}({});
let ConfirmResult = /* @__PURE__ */ function(ConfirmResult$1) {
	ConfirmResult$1["YES"] = "yes";
	ConfirmResult$1["NO"] = "no";
	ConfirmResult$1["IGNORE"] = "ignore";
	return ConfirmResult$1;
}({});
let HttpLibrary = /* @__PURE__ */ function(HttpLibrary$1) {
	HttpLibrary$1["EXPRESS"] = "express";
	HttpLibrary$1["FASTIFY"] = "fastify";
	HttpLibrary$1["KOA"] = "koa";
	HttpLibrary$1["HONO"] = "hono";
	return HttpLibrary$1;
}({});

//#endregion
//#region src/utils.ts
const isValidPackageName = (packageName) => {
	return /^(?:@[a-z\d\-*~][a-z\d\-*._~]*\/)?[a-z\d\-~][a-z\d\-._~]*$/.test(packageName);
};
const toValidPackageName = (packageName) => packageName.trim().toLowerCase().replace(/\s+/g, "-").replace(/^[._]/, "").replace(/[^a-z\d\-~]+/g, "-");
const toValidProjectName = (projectName) => projectName.trim().replace(/\/+$/g, "");
const emptyDir = async (dir, ignore = []) => {
	if (!(0, node_fs.existsSync)(dir)) return false;
	for (const file of await (0, node_fs_promises.readdir)(dir)) {
		if (ignore.includes(file)) continue;
		await (0, node_fs_promises.rm)((0, node_path.resolve)(dir, file), {
			recursive: true,
			force: true
		});
	}
	return true;
};
const isEmpty = async (path, ignore = []) => {
	return (await (0, node_fs_promises.readdir)(path)).filter((f) => !ignore.includes(f)).length === 0;
};
const editFile = async (file, callback) => {
	if (!(0, node_fs.existsSync)(file)) return;
	return (0, node_fs_promises.writeFile)(file, callback(await (0, node_fs_promises.readFile)(file, "utf-8")), "utf-8");
};
const editJsonFile = (file, callback) => {
	return editFile(file, (str) => {
		try {
			const json = JSON.parse(str);
			callback(json);
			return JSON.stringify(json, null, 2);
		} catch (e) {
			console.error(e);
			return str;
		}
	});
};
const readSubDirs = async (source, ignore = []) => {
	return (await (0, node_fs_promises.readdir)(source, { withFileTypes: true })).filter((k) => k.isDirectory() && !ignore.includes(k.name)).map((dir) => dir.name);
};
const copyDirAsync = async (src, dest, options) => {
	await (0, node_fs_promises.mkdir)(dest, { recursive: true });
	const entries = await (0, node_fs_promises.readdir)(src, { withFileTypes: true });
	for (const entry of entries) {
		const name = entry.name;
		const isDir = entry.isDirectory();
		const { rename = {}, skips = [] } = options;
		const relName = rename[name] ?? name;
		if (skips.some((rule) => rule(name, isDir))) continue;
		const from = (0, node_path.join)(src, name);
		const to = (0, node_path.join)(dest, relName);
		if (isDir) await copyDirAsync(from, to, options);
		else await (0, node_fs_promises.copyFile)(from, to);
	}
};
const readJsonFile = (file) => {
	if (!(0, node_fs.existsSync)(file)) return {};
	try {
		return JSON.parse((0, node_fs.readFileSync)(file, "utf-8"));
	} catch (e) {
		return {};
	}
};
/** 通过包管理器执行脚本时生效 UserAgent: `process.env.npm_config_user_agent` */
const pkgFromUserAgent = (userAgent) => {
	if (!userAgent) return void 0;
	const [name, version] = userAgent.split(" ")[0].split("/");
	return {
		name,
		version
	};
};
/** 同步执行 Node CLI（用于测试环境） */
const runCliForTest = (path, args, options) => {
	return (0, node_child_process.spawnSync)("node", [path, ...args], {
		env: {
			...process.env,
			_VITE_TEST_CLI: "true"
		},
		encoding: "utf-8",
		...options
	});
};
/** 判断测试文件（夹） */
const isTestFile = (name) => {
	return [
		/(^|[\\/])(test(s?)|__test(s?)__)([\\/]|$)/,
		/\.([a-zA-Z0-9]+-)?(test|spec)\.m?(ts|js)$/,
		/^vitest([-.])(.*)\.m?(ts|js)$/
	].some((reg) => reg.test(name));
};
const parseGitHubRepo = (url) => {
	const match = url.trim().match(/github(?:\.com)?[:/](.+?)\/(.+?)(?:[#/?].+?)?(?:\.git)?$/);
	return match ? match.slice(1, 3) : [];
};

//#endregion
//#region src/shell.ts
const dim = (text) => (0, node_util.styleText)(["dim"], text);
const red = (text) => (0, node_util.styleText)(["red"], text);
const yellow = (text) => (0, node_util.styleText)(["yellow"], text);
const spawnAsync = (cmd, args, options) => {
	return new Promise((resolve$1) => {
		const { trim, error, dryRun, ...others } = options ?? {};
		const fullCmd = [cmd, ...args].join(" ");
		if (dryRun) {
			console.log(`${dim("[dry-run]")} ${fullCmd}`);
			return resolve$1(void 0);
		}
		const child = (0, node_child_process.spawn)(cmd, args, { ...others });
		let stdout = "";
		child.stdout?.setEncoding("utf-8");
		child.stdout?.on("data", (data) => stdout += trim ? data.trim() : data);
		let stderr = "";
		child.stderr?.setEncoding("utf-8");
		child.stderr?.on("data", (data) => stderr += trim ? data.trim() : data);
		child.on("close", (code) => {
			if (stderr) {
				const err = `${red("spawnAsync")} ${dim(fullCmd)} ${stderr}`;
				switch (error) {
					case "log":
						console.error(err);
						break;
					case "throw": throw new Error(err);
				}
			}
			resolve$1(0 === code ? stdout : void 0);
		});
	});
};
const execAsync = (cmd, options) => {
	return new Promise((resolve$1) => {
		const { trim, dryRun, error, ...others } = options ?? {};
		if (dryRun) {
			console.log(`${dim("[dry-run]")} ${cmd}`);
			return resolve$1(void 0);
		}
		(0, node_child_process.exec)(cmd, { ...others }, (err, stdout) => {
			if (err) {
				const msg = `${red("execAsync")} ${dim(cmd)} ${err.message}`;
				switch (error) {
					case "log":
						console.error(msg);
						break;
					case "throw": throw new Error(msg);
				}
			}
			resolve$1(err ? void 0 : trim ? stdout.trim() : stdout);
		});
	});
};
const runGit = async (args, trim = true) => {
	return spawnAsync("git", args, { trim });
};
const runNpm = (args) => {
	return execAsync(["npm", ...args].join(" "));
};
const isGitRepo = async (dir) => {
	return !!await runGit([
		"-C",
		dir ? `./${dir}` : ".",
		"rev-parse",
		"--is-inside-work-tree"
	]);
};
const getGitConfig = (key, global = true) => {
	return runGit([
		"config",
		...global ? ["--global"] : [],
		key
	]);
};
const getGitRemoteUrl = async (remoteName = "origin") => {
	return runGit([
		"remote",
		"get-url",
		remoteName
	]).catch((_) => runGit([
		"config",
		"--get",
		`remote.${remoteName}.url`
	]));
};
const pkgVersion = (pkg) => {
	return runNpm([
		"view",
		pkg,
		"version"
	]);
};
const checkVersion = async (cmd) => {
	return execAsync(`${cmd} --version`);
};

//#endregion
exports.ConfirmResult = ConfirmResult;
exports.HttpLibrary = HttpLibrary;
exports.PkgManager = PkgManager;
exports.YesOrNo = YesOrNo;
exports.checkVersion = checkVersion;
exports.copyDirAsync = copyDirAsync;
exports.dim = dim;
exports.editFile = editFile;
exports.editJsonFile = editJsonFile;
exports.emptyDir = emptyDir;
exports.execAsync = execAsync;
exports.getGitConfig = getGitConfig;
exports.getGitRemoteUrl = getGitRemoteUrl;
exports.isEmpty = isEmpty;
exports.isGitRepo = isGitRepo;
exports.isTestFile = isTestFile;
exports.isValidPackageName = isValidPackageName;
exports.parseGitHubRepo = parseGitHubRepo;
exports.pkgFromUserAgent = pkgFromUserAgent;
exports.pkgVersion = pkgVersion;
exports.readJsonFile = readJsonFile;
exports.readSubDirs = readSubDirs;
exports.red = red;
exports.runCliForTest = runCliForTest;
exports.runGit = runGit;
exports.runNpm = runNpm;
exports.spawnAsync = spawnAsync;
exports.toValidPackageName = toValidPackageName;
exports.toValidProjectName = toValidProjectName;
exports.yellow = yellow;