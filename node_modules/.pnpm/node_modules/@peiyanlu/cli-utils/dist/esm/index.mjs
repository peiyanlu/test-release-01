import { exec, spawn, spawnSync } from "node:child_process";
import { existsSync, readFileSync } from "node:fs";
import { copyFile, mkdir, readFile, readdir, rm, writeFile } from "node:fs/promises";
import { join, resolve } from "node:path";
import { styleText } from "node:util";

//#region src/enums.ts
let PkgManager = /* @__PURE__ */ function(PkgManager$1) {
	PkgManager$1["NPM"] = "npm";
	PkgManager$1["YARN"] = "yarn";
	PkgManager$1["PNPM"] = "pnpm";
	return PkgManager$1;
}({});
/**
* @deprecated Use `ConfirmResult` instead.
*/
let YesOrNo = /* @__PURE__ */ function(YesOrNo$1) {
	YesOrNo$1["Yes"] = "yes";
	YesOrNo$1["No"] = "no";
	YesOrNo$1["Ignore"] = "ignore";
	return YesOrNo$1;
}({});
let ConfirmResult = /* @__PURE__ */ function(ConfirmResult$1) {
	ConfirmResult$1["YES"] = "yes";
	ConfirmResult$1["NO"] = "no";
	ConfirmResult$1["IGNORE"] = "ignore";
	return ConfirmResult$1;
}({});
let HttpLibrary = /* @__PURE__ */ function(HttpLibrary$1) {
	HttpLibrary$1["EXPRESS"] = "express";
	HttpLibrary$1["FASTIFY"] = "fastify";
	HttpLibrary$1["KOA"] = "koa";
	HttpLibrary$1["HONO"] = "hono";
	return HttpLibrary$1;
}({});

//#endregion
//#region src/utils.ts
const isValidPackageName = (packageName) => {
	return /^(?:@[a-z\d\-*~][a-z\d\-*._~]*\/)?[a-z\d\-~][a-z\d\-._~]*$/.test(packageName);
};
const toValidPackageName = (packageName) => packageName.trim().toLowerCase().replace(/\s+/g, "-").replace(/^[._]/, "").replace(/[^a-z\d\-~]+/g, "-");
const toValidProjectName = (projectName) => projectName.trim().replace(/\/+$/g, "");
const emptyDir = async (dir, ignore = []) => {
	if (!existsSync(dir)) return false;
	for (const file of await readdir(dir)) {
		if (ignore.includes(file)) continue;
		await rm(resolve(dir, file), {
			recursive: true,
			force: true
		});
	}
	return true;
};
const isEmpty = async (path, ignore = []) => {
	return (await readdir(path)).filter((f) => !ignore.includes(f)).length === 0;
};
const editFile = async (file, callback) => {
	if (!existsSync(file)) return;
	return writeFile(file, callback(await readFile(file, "utf-8")), "utf-8");
};
const editJsonFile = (file, callback) => {
	return editFile(file, (str) => {
		try {
			const json = JSON.parse(str);
			callback(json);
			return JSON.stringify(json, null, 2);
		} catch (e) {
			console.error(e);
			return str;
		}
	});
};
const readSubDirs = async (source, ignore = []) => {
	return (await readdir(source, { withFileTypes: true })).filter((k) => k.isDirectory() && !ignore.includes(k.name)).map((dir) => dir.name);
};
const copyDirAsync = async (src, dest, options) => {
	await mkdir(dest, { recursive: true });
	const entries = await readdir(src, { withFileTypes: true });
	for (const entry of entries) {
		const name = entry.name;
		const isDir = entry.isDirectory();
		const { rename = {}, skips = [] } = options;
		const relName = rename[name] ?? name;
		if (skips.some((rule) => rule(name, isDir))) continue;
		const from = join(src, name);
		const to = join(dest, relName);
		if (isDir) await copyDirAsync(from, to, options);
		else await copyFile(from, to);
	}
};
const readJsonFile = (file) => {
	if (!existsSync(file)) return {};
	try {
		return JSON.parse(readFileSync(file, "utf-8"));
	} catch (e) {
		return {};
	}
};
/** 通过包管理器执行脚本时生效 UserAgent: `process.env.npm_config_user_agent` */
const pkgFromUserAgent = (userAgent) => {
	if (!userAgent) return void 0;
	const [name, version] = userAgent.split(" ")[0].split("/");
	return {
		name,
		version
	};
};
/** 同步执行 Node CLI（用于测试环境） */
const runCliForTest = (path, args, options) => {
	return spawnSync("node", [path, ...args], {
		env: {
			...process.env,
			_VITE_TEST_CLI: "true"
		},
		encoding: "utf-8",
		...options
	});
};
/** 判断测试文件（夹） */
const isTestFile = (name) => {
	return [
		/(^|[\\/])(test(s?)|__test(s?)__)([\\/]|$)/,
		/\.([a-zA-Z0-9]+-)?(test|spec)\.m?(ts|js)$/,
		/^vitest([-.])(.*)\.m?(ts|js)$/
	].some((reg) => reg.test(name));
};
const parseGitHubRepo = (url) => {
	const match = url.trim().match(/github(?:\.com)?[:/](.+?)\/(.+?)(?:[#/?].+?)?(?:\.git)?$/);
	return match ? match.slice(1, 3) : [];
};

//#endregion
//#region src/shell.ts
const dim = (text) => styleText(["dim"], text);
const red = (text) => styleText(["red"], text);
const yellow = (text) => styleText(["yellow"], text);
const spawnAsync = (cmd, args, options) => {
	return new Promise((resolve$1) => {
		const { trim, error, dryRun, ...others } = options ?? {};
		const fullCmd = [cmd, ...args].join(" ");
		if (dryRun) {
			console.log(`${dim("[dry-run]")} ${fullCmd}`);
			return resolve$1(void 0);
		}
		const child = spawn(cmd, args, { ...others });
		let stdout = "";
		child.stdout?.setEncoding("utf-8");
		child.stdout?.on("data", (data) => stdout += trim ? data.trim() : data);
		let stderr = "";
		child.stderr?.setEncoding("utf-8");
		child.stderr?.on("data", (data) => stderr += trim ? data.trim() : data);
		child.on("close", (code) => {
			if (stderr) {
				const err = `${red("spawnAsync")} ${dim(fullCmd)} ${stderr}`;
				switch (error) {
					case "log":
						console.error(err);
						break;
					case "throw": throw new Error(err);
				}
			}
			resolve$1(0 === code ? stdout : void 0);
		});
	});
};
const execAsync = (cmd, options) => {
	return new Promise((resolve$1) => {
		const { trim, dryRun, error, ...others } = options ?? {};
		if (dryRun) {
			console.log(`${dim("[dry-run]")} ${cmd}`);
			return resolve$1(void 0);
		}
		exec(cmd, { ...others }, (err, stdout) => {
			if (err) {
				const msg = `${red("execAsync")} ${dim(cmd)} ${err.message}`;
				switch (error) {
					case "log":
						console.error(msg);
						break;
					case "throw": throw new Error(msg);
				}
			}
			resolve$1(err ? void 0 : trim ? stdout.trim() : stdout);
		});
	});
};
const runGit = async (args, trim = true) => {
	return spawnAsync("git", args, { trim });
};
const runNpm = (args) => {
	return execAsync(["npm", ...args].join(" "));
};
const isGitRepo = async (dir) => {
	return !!await runGit([
		"-C",
		dir ? `./${dir}` : ".",
		"rev-parse",
		"--is-inside-work-tree"
	]);
};
const getGitConfig = (key, global = true) => {
	return runGit([
		"config",
		...global ? ["--global"] : [],
		key
	]);
};
const getGitRemoteUrl = async (remoteName = "origin") => {
	return runGit([
		"remote",
		"get-url",
		remoteName
	]).catch((_) => runGit([
		"config",
		"--get",
		`remote.${remoteName}.url`
	]));
};
const pkgVersion = (pkg) => {
	return runNpm([
		"view",
		pkg,
		"version"
	]);
};
const checkVersion = async (cmd) => {
	return execAsync(`${cmd} --version`);
};

//#endregion
export { ConfirmResult, HttpLibrary, PkgManager, YesOrNo, checkVersion, copyDirAsync, dim, editFile, editJsonFile, emptyDir, execAsync, getGitConfig, getGitRemoteUrl, isEmpty, isGitRepo, isTestFile, isValidPackageName, parseGitHubRepo, pkgFromUserAgent, pkgVersion, readJsonFile, readSubDirs, red, runCliForTest, runGit, runNpm, spawnAsync, toValidPackageName, toValidProjectName, yellow };