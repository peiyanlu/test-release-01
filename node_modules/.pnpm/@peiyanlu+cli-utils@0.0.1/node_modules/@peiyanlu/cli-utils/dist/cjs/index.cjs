let node_child_process = require("node:child_process");
let node_fs = require("node:fs");
let node_fs_promises = require("node:fs/promises");
let node_path = require("node:path");

//#region src/enums.ts
let PkgManager = /* @__PURE__ */ function(PkgManager$1) {
	PkgManager$1["NPM"] = "npm";
	PkgManager$1["YARN"] = "yarn";
	PkgManager$1["PNPM"] = "pnpm";
	return PkgManager$1;
}({});
/**
* @deprecated Use `ConfirmResult` instead.
*/
let YesOrNo = /* @__PURE__ */ function(YesOrNo$1) {
	YesOrNo$1["Yes"] = "yes";
	YesOrNo$1["No"] = "no";
	YesOrNo$1["Ignore"] = "ignore";
	return YesOrNo$1;
}({});
let ConfirmResult = /* @__PURE__ */ function(ConfirmResult$1) {
	ConfirmResult$1["YES"] = "yes";
	ConfirmResult$1["NO"] = "no";
	ConfirmResult$1["IGNORE"] = "ignore";
	return ConfirmResult$1;
}({});
let HttpLibrary = /* @__PURE__ */ function(HttpLibrary$1) {
	HttpLibrary$1["EXPRESS"] = "express";
	HttpLibrary$1["FASTIFY"] = "fastify";
	HttpLibrary$1["KOA"] = "koa";
	HttpLibrary$1["HONO"] = "hono";
	return HttpLibrary$1;
}({});

//#endregion
//#region src/utils.ts
const execAsync = (cmd) => {
	return new Promise((r) => {
		(0, node_child_process.exec)(cmd, (err, stdout) => r(err ? void 0 : stdout.trim()));
	});
};
const pkgVersion = (pkg) => {
	return execAsync(`npm view ${pkg} version`);
};
const checkVersion = async (cmd) => {
	return execAsync(`${cmd} --version`);
};
const isValidPackageName = (packageName) => {
	return /^(?:@[a-z\d\-*~][a-z\d\-*._~]*\/)?[a-z\d\-~][a-z\d\-._~]*$/.test(packageName);
};
const toValidPackageName = (packageName) => packageName.trim().toLowerCase().replace(/\s+/g, "-").replace(/^[._]/, "").replace(/[^a-z\d\-~]+/g, "-");
const toValidProjectName = (projectName) => projectName.trim().replace(/\/+$/g, "");
const emptyDir = async (dir, ignore = []) => {
	if (!(0, node_fs.existsSync)(dir)) return false;
	for (const file of await (0, node_fs_promises.readdir)(dir)) {
		if (ignore.includes(file)) continue;
		await (0, node_fs_promises.rm)((0, node_path.resolve)(dir, file), {
			recursive: true,
			force: true
		});
	}
	return true;
};
const isEmpty = async (path, ignore = []) => {
	return (await (0, node_fs_promises.readdir)(path)).filter((f) => !ignore.includes(f)).length === 0;
};
const editFile = async (file, callback) => {
	if (!(0, node_fs.existsSync)(file)) return;
	return (0, node_fs_promises.writeFile)(file, callback(await (0, node_fs_promises.readFile)(file, "utf-8")), "utf-8");
};
const editJsonFile = (file, callback) => {
	return editFile(file, (str) => {
		try {
			const json = JSON.parse(str);
			callback(json);
			return JSON.stringify(json, null, 2);
		} catch (e) {
			console.error(e);
			return str;
		}
	});
};
const isGitRepo = async (dir) => {
	return !!await execAsync(`git -C "${dir ? `./${dir}` : "."}" rev-parse --is-inside-work-tree`);
};
const readSubDirs = async (source, ignore = []) => {
	return (await (0, node_fs_promises.readdir)(source, { withFileTypes: true })).filter((k) => k.isDirectory() && !ignore.includes(k.name)).map((dir) => dir.name);
};
const getGitConfig = (key, global = true) => {
	return execAsync(`git config ${global ? "--global" : ""} ${key}`);
};
const copyDirAsync = async (src, dest, options) => {
	await (0, node_fs_promises.mkdir)(dest, { recursive: true });
	const entries = await (0, node_fs_promises.readdir)(src, { withFileTypes: true });
	for (const entry of entries) {
		const name = entry.name;
		const isDir = entry.isDirectory();
		const { rename = {}, skips = [] } = options;
		const relName = rename[name] ?? name;
		if (skips.some((rule) => rule(name, isDir))) continue;
		const from = (0, node_path.join)(src, name);
		const to = (0, node_path.join)(dest, relName);
		if (isDir) await copyDirAsync(from, to, options);
		else await (0, node_fs_promises.copyFile)(from, to);
	}
};
const readJsonFile = (file) => {
	if (!(0, node_fs.existsSync)(file)) return {};
	try {
		return JSON.parse((0, node_fs.readFileSync)(file, "utf-8"));
	} catch (e) {
		return {};
	}
};
/**
* 通过包管理器执行脚本时生效
*
* UserAgent: `process.env.npm_config_user_agent`
* @param {string | undefined} userAgent
* @returns {PkgInfo | undefined}
*/
const pkgFromUserAgent = (userAgent) => {
	if (!userAgent) return void 0;
	const [name, version] = userAgent.split(" ")[0].split("/");
	return {
		name,
		version
	};
};
const runCli = (path, args, options) => {
	return (0, node_child_process.spawnSync)("node", [path, ...args], {
		env: {
			...process.env,
			_VITE_TEST_CLI: "true"
		},
		encoding: "utf-8",
		...options
	});
};

//#endregion
exports.ConfirmResult = ConfirmResult;
exports.HttpLibrary = HttpLibrary;
exports.PkgManager = PkgManager;
exports.YesOrNo = YesOrNo;
exports.checkVersion = checkVersion;
exports.copyDirAsync = copyDirAsync;
exports.editFile = editFile;
exports.editJsonFile = editJsonFile;
exports.emptyDir = emptyDir;
exports.execAsync = execAsync;
exports.getGitConfig = getGitConfig;
exports.isEmpty = isEmpty;
exports.isGitRepo = isGitRepo;
exports.isValidPackageName = isValidPackageName;
exports.pkgFromUserAgent = pkgFromUserAgent;
exports.pkgVersion = pkgVersion;
exports.readJsonFile = readJsonFile;
exports.readSubDirs = readSubDirs;
exports.runCli = runCli;
exports.toValidPackageName = toValidPackageName;
exports.toValidProjectName = toValidProjectName;